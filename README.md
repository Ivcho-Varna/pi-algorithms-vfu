# Алгоритми за приближение на π в Elixir

Цялостна реализация и тестов пакет за три класически алгоритма, които приближават математическата константа π (пи) с помощта на Elixir. Всеки алгоритъм е реализиран както в рекурсивна, така и в итеративна форма.

## Общ преглед

Този проект изследва различни математически подходи за изчисляване на π, сравнявайки тяхната точност, скорост и изчислителни характеристики. Всички алгоритми са реализирани с използване на функционални програмни парадигми в Elixir.

## Реализирани алгоритми

### 1. Ред на Лайбниц
**Файл:** `leibniz.exs`

Приближава π чрез формулата на Leibniz (известна още като ред на Грегъри-Лайбниц):

```
π = 4 × (1 - 1/3 + 1/5 - 1/7 + 1/9 - ...)
```

**Реализации:**
- `PiLeibniz.leibniz_recursive/1` - Не-опашкова рекурсивна реализация
- `PiLeibniz.leibniz_iterative/1` - Опашкова рекурсивна (итеративна) реализация с акумулатор

### 2. Произведение на Уолис
**Файл:** `wallis.exs`

Приближава π чрез формулата на Wallis:

```
π/2 = (2/1) × (2/3) × (4/3) × (4/5) × (6/5) × (6/7) × ...
π = 2 × ∏[k=1 до n] (4k²) / (4k² - 1)
```

**Реализации:**
- `PiWallis.wallis_recursive/1` - Не-опашкова рекурсивна реализация
- `PiWallis.wallis_iterative/1` - Опашкова рекурсивна (итеративна) реализация с акумулатор

### 3. Ред на Ниляканта
**Файл:** `nilakantha.exs`

Приближава π чрез реда на Nilakantha:

```
π = 3 + 4/(2×3×4) - 4/(4×5×6) + 4/(6×7×8) - ...
π = 3 + ∑[k=1 до n] (-1)^(k+1) × 4 / ((2k)(2k+1)(2k+2))
```

**Реализации:**
- `PiNilakantha.nilakantha_recursive/1` - Не-опашкова рекурсивна реализация
- `PiNilakantha.nilakantha_iterative/1` - Опашкова рекурсивна (итеративна) реализация с акумулатор

## Структура на проекта

```
c:\projects\elixir\
├── README.md              # Този файл
├── leibniz.exs           # Реализация на реда на Лайбниц
├── wallis.exs            # Реализация на произведението на Уолис
├── nilakantha.exs        # Реализация на реда на Ниляканта
└── tests/
    ├── benchmark.exs     # Помощни функции за измерване
    ├── accuracy_test.exs # Тестове за сравнение на точност
    └── speed_test.exs    # Тестове за сравнение на скорост
```

## Изисквания

- **Elixir:** версия 1.12 или по-нова
- **Erlang/OTP:** версия 22 или по-нова

## Инсталация

1. Клонирайте или изтеглете това хранилище
2. Уверете се, че Elixir е инсталиран на системата ви
3. Навигирайте до директорията на проекта

```bash
cd c:\projects\elixir
```

## Употреба

### Изпълнение на отделни алгоритми

Можете да използвате всеки алгоритъм директно в Elixir скрипт или IEx:

```elixir
# Зареждане на модула
Code.require_file("leibniz.exs")

# Приближаване на π чрез Лайбниц с 10000 итерации
PiLeibniz.leibniz_iterative(10000)
# => 3.1414926535900345

# Зареждане и използване на Уолис
Code.require_file("wallis.exs")
PiWallis.wallis_iterative(10000)
# => 3.1414971639472924

# Зареждане и използване на Ниляканта
Code.require_file("nilakantha.exs")
PiNilakantha.nilakantha_iterative(10000)
# => 3.1415926035898384
```

### Изпълнение на тестове

#### Тест за точност
Определя минималния брой итерации, необходими на всеки алгоритъм, за да постигне определен толеранс от действителната стойност на π.

```bash
elixir tests\accuracy_test.exs
```

**Изходът включва:**
- Минимални необходими итерации
- Краен резултат
- Грешка от действителното π
- Статус на постигане

#### Тест за скорост
Измерва времето за изпълнение и точността на всеки алгоритъм с фиксиран брой итерации.

```bash
elixir tests\speed_test.exs
```

**Изходът включва:**
- Време за изпълнение в милисекунди
- Получено приближение
- Грешка от действителното π
- Дълбочина на рекурсията

## Помощни функции за измерване

Модулът `Benchmark` (в `tests/benchmark.exs`) предоставя три основни функции за измерване:

### `measure_accuracy/5`
Намира минималния брой итерации, необходими за постигане на целева точност, използвайки оптимизация с двоично търсене.

```elixir
Benchmark.measure_accuracy(PiLeibniz, :leibniz_iterative, :math.pi(), 0.001, 100_000)
```

**Параметри:**
- `module` - Модулът, съдържащ алгоритъма
- `function` - Името на функцията (атом)
- `target_value` - Целева стойност на π (обикновено `:math.pi()`)
- `tolerance` - Допустим марджин на грешка (по подразбиране: 0.001)
- `max_iterations` - Максимални итерации за тестване (по подразбиране: 100,000)

### `measure_speed/3`
Измерва общото време за изпълнение за определен брой итерации.

```elixir
Benchmark.measure_speed(PiWallis, :wallis_iterative, 10000)
```

### `measure_recursion_depth/1`
Отчита дълбочината на рекурсията за даден брой итерации.

```elixir
Benchmark.measure_recursion_depth(1000)
```

**Параметри:**
- `module` - Модулът, съдържащ алгоритъма
- `function` - Navnet на функцията (атом)
- `iterations` - Брой итерации за изпълнение

## Проведени тестове

<!-- Секция за резултати от тестовете - ще бъде добавена по-късно -->

Резултатите от тестовете и анализът ще бъдат документирани тук._

## Справки

- [Формула на Лайбниц за Pi](https://en.wikipedia.org/wiki/Leibniz_formula_for_%CF%80)
- [Произведение на Уолис](https://en.wikipedia.org/wiki/Wallis_product)
- [Ред на Ниляканта](https://en.wikipedia.org/wiki/Pi#Efficient_methods)
- [Документация на Elixir](https://elixir-lang.org/docs.html)
